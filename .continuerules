# How to communicate

* Please provide concise answers.
* If a request is complex, instead of providing a wrong answer, tell me what steps need to be taken in order to fulfill the task.
* If you lack information or context to complete a task, ask for the information. E.g. if details about the current code are missing from the task or the task is vague and lacking specifity.
* You can assume that I am knowledgable about most programming topics.
* If you generate code it should try to use few libraries and be fast while maintaining readability.


# Project Vision

Quack Norris is a web application that allows users to interact with an AI assistant through a chat interface.
The application allows connecting to different Large Language Models (LLMs) via an OpenAI API and provides a chat interface for users to communicate with the AI.
Additionally it supports MCP (Model Context Protocol) over http to connect tools to the AI.

The AI assistant can be adjusted in its capabilities based on the users needs.
1. Just use the LLM (no tools no agentic loop).
2. Use MCP tools (e.g. for web search, file search, etc.).
3. Use an agentic loop, where the AI enriches its context by calling tools and once it has enough information, it answers the user.

When using MCP or the agentic loop, the AI will cite the used contexts in its answers and allows to view the context used for the answer.
This increases the transparency and allows users to understand how the AI arrived at its conclusions.

# Overall Architecture

The application is a pure client-side web application, built with TypeScript and Vite.
Internally it has two parts:
1. The AI implemmentation
  * directly call llm, if neigher MCP nor agentic loop enabled
  * use agentic loop, if MCP or agentic loop enabled (just mcp is an agentic loop with max 1 iteration)
2. Chat Window
  * Layout:
    - Clean, modern design with message bubbles that distinguish between user and AI messages.
    - Text-based messages are easy to read and well-formatted.
    - Supports rich media embedding (images, audio files) inline within chat messages.
  * Features:
    - [X] Message input area at the bottom with a text box for typing.
    - [X] File drag-and-drop zone: Users can drag and drop images or files directly into the chat window to add them as attachments.
    - [X] File attachment button: A button that allows to attach files (images, PDFs, etc.) to messages.
    - [X] Clipboard integration: If an image is in the clipboard (e.g., screenshot), the user can paste it (CTRL + V) as an attachment to the chat message.
    - [X] A dropdown menu allows switching the llm-model of a conversation
    - [ ] A menu allows switching the conversation (chat history), deleting and creating new ones.
    - [ ] Settings allow configuration of OpenAI API keys, MCP endpoints, and other preferences.
    - [ ] Quick action buttons allow toggling MCP and agentic loop
    - [ ] (Optional) Chat histories can be saved on a WebFS Server as Markdown.
    - [ ] (Optional) Supports audio transcription: Clicking a button toggles "audio call mode", where speech is transcribed into the text message box in real-time and responses are spoken aloud using text-to-speech (TTS).


# Repository Structure
quack-norris  (__init__.py skipped for readability)
├───dist                # Contains the built files for the web app
├───images              # Contains images used in the documentation
├───node_modules        # Contains the dependencies installed by npm
├───public              # Contains static assets that are served by the web server
└───src                 # Contains the typescript source code for the app
    ├───ai_chat         # Contains the main chat functionality and components
    │   └───utils       # Connections to llm, tools, MCPs and other AI-related utilities
    ├───language        # Contains the translations and strings for the UI
    └───webui           # Submodule for general ui components (shared with other projects)
        ├───components  # Reusable UI components
        └───utils       # Utility functions for the UI


# Dependencies

The project has only very few external dependencies, so that it is unlikely to break due to outside circumstances.
It just uses vite, marked and marked.


## Additional Considerations

1. The code has a clear structure, which makes it easy to understand and navigate.
2. The code is extensible and maintainable, so that it can be easily extended in the future.
3. The code is testable, so its stability can be ensured.
